const { see, hourglass } = require("code_clarity")
const { upset } = require("whats_wrong")
const { tableColValCount } = require("./counts")
const knex = require("knex")({
    client: "postgresql",
    connection: {
        database: "optee3",
        user: "postgres",
        password: "postgres",
    }
})
async function delById(knex, table, id) {
    try {
        let deleted = await knex(table).where({ id: id }).del()
        return deleted;
    } catch (error) {
        upset("not able to get one" + error, "effective_knex, get one", "should be able to return an object")
    }
}
/**
 * @author github.com/zen-out
 */
async function delByKeyValue(knex, table, key, value) {
    let newObj = {}
    newObj[key] = value;
    try {
        let deleted = await knex(table).where(newObj).del()
        return true;
    } catch (error) {
        see.problem(error)
        upset("not able to get one" + error, "effective_knex, get one", "should be able to return an object")
        return false;
    }
}

/**
 * @example
 * await deleteFromOtherTables(knex, table, id, arrOfOtherTables)
 * @author github.com/zen-out
 */
async function deleteFromOtherTables(knex, table, id, arrOfOtherTables) {
    try {
        let foreign_id = `${table}_id`
        for (let i = 0; i < arrOfOtherTables.length; i++) {
            await delByKeyValue(knex, arrOfOtherTables[i], foreign_id, id)
            let trueOrFalse = await tableColValCount(knex, arrOfOtherTables[i], foreign_id, id)
            if (trueOrFalse !== 0) {
                see.problem("not able to delete")
            }
        }
    } catch (error) {
        return upset("not able to delete from other tables" + error, "effective_knex, delete one", "should be able to delete")
    }
}
/**
* @description 
* - If there is a fourth parameter
* - Get foreign id by table_id
* - Delete from other tables 
* - 
* @example
* del(knex, table, id, arrOfOtherTables = undefined)
* let result2 = await del(knex, "hourglass", 54, ["problem"]).then((result) => {
      let check = typeof result === "object"
      return check;
  })
* @author zen-out
* @date 2022-03-10
* @returns {number}
*/
async function del(knex, table, id, arrOfOtherTables = undefined) {
    try {
        if (arrOfOtherTables) {
            await deleteFromOtherTables(knex, table, id, arrOfOtherTables)
            await delById(knex, table, id)
            return id;
        } else {
            await delById(knex, table, id)
            return id;
        }
    } catch (error) {
        upset("not able to delete from other tables" + error, "effective_knex, delete one", "should be able to delete")
    }
}
async function testDelete() {
    let getHourglassId;
    let postZero = {
        "importance": 1
    }
    let postOne = {
        "problem": "problem",
        "hourglass_id": 12
    }
    return knex("hourglass").returning("id").insert(postZero).then((id) => {
        console.log(id)
        getHourglassId = id[0].id
        let problem = {
            "problem": "problem",
            "hourglass_id": getHourglassId
        }
        return problem
    }).then((problem) => {
        let newObj = { hourglass_id: problem.hourglass_id }
        return knex("problem").returning("id").insert(postOne).then((id) => {
            newObj["problem_id"] = id[0].id
            return newObj;
        })

    }).then((result) => {
        let hg = result.hourglass_id
        let problem = result.problem_id
        return del(knex, "hourglass", hg, ["problem"])
    }).then((shouldGetId) => {
        console.log("ðŸš€ ~ file: basic.js ~ line 156 ~ returnknex ~ shouldGetId", shouldGetId)
        if (shouldGetId === getHourglassId) {
            see.done("TEST: delete passes")
            return true;
        } else {
            see.problem("delete doesnt work")
            return false;
        }
    })
}
// testDelete()

module.exports = { delById, delByKeyValue, deleteFromOtherTables, del, testDelete };